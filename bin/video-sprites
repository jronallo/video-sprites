#!/usr/bin/env ruby

require 'slop'
require 'fileutils'
require 'pry'

opts = Slop.new strict: true do
  banner 'Usage: video-sprites [options]'

  on 'f', 'frames=', 'An optional password', argument: :optional, as: Integer, default: 5
  on 'w', 'width=', 'Width of each thumbnail', argument: :optional, as: Integer, default: 200
  on 'c', 'columns=', 'Number of columns in the image sprite', argument: :optional, as: Integer, default: 5
  on 'k', 'keep', 'Keep all the individual images and other intermediate artifacts.', argument: :optional
  on 'i', 'input=', 'Input file or directory', required: true
  on 'o', 'output=', 'Output file or directory', argument: :optional
  on 'v', 'verbose', 'Enable verbose mode'
  on 'h', 'help', 'Help!!!'
end


begin
  opts.parse
rescue Slop::Error => e
  puts e.message
  puts opts # print help
end

verbose = opts[:verbose]
input = File.expand_path(opts[:input])

unless File.exist?(input)
  puts "File or directory does not exist!"
  exit
end

if verbose
  puts "Input file: #{input}"
end

if File.directory?(input)
  files = Dir.glob(File.join(input, '*'))
else
  files = [input]
end

if opts[:output]
  output_directory = File.expand_path(opts[:output])
else
    if File.directory?(input)
      output_directory = input
      puts "output dir is #{output_directory}" if verbose
    else
      output_directory = File.dirname(input)
      puts "output dir is #{output_directory}" if verbose
    end
end

files.each do | file |
  puts "Processing file: #{file}" if verbose
  extension = File.extname(file)
  basename =  File.basename(file, extension)
  puts "Basename is: #{basename}" if verbose

  output_path = File.join(output_directory, basename)

  if File.directory?(input)
    FileUtils.mkdir_p(output_path)
    output_file_path = File.join(output_directory, basename, basename)
  end

  # FIXME: check if the files exist already and maybe don't process anything

  ffmpeg_cmd = %Q|ffmpeg -i "#{file}" -f image2 -vf fps=fps=1/#{opts[:frames]} "#{output_file_path}-%05d.jpg"|
  puts ffmpeg_cmd if verbose
  `#{ffmpeg_cmd}`

  montage_cmd = %Q|montage #{output_path}*jpg -tile #{opts[:columns]}x -geometry #{opts[:width]}x #{output_file_path}-sprite.jpg|
  puts montage_cmd if verbose

  `#{montage_cmd}`

  # Create WebVTT file
  jpegs = Dir.glob(File.join(output_path, '*.jpg'))
  if verbose
    puts "Processing a WebVTT file from these images:"
    puts jpegs
  end
  # place all the cues into an array of hashes like this:
  # {start: 0, end: 5, x: 0, y: 0, w: 200, h: 150}
  cues = []

  start = 0
  first_jpeg = jpegs.first
  height = `identify -format "%h" -ping #{first_jpeg}`.to_i
  jpegs.each_with_index do |image, index|
    puts "Index: #{index}" if verbose
    cue = {}
    cue[:start] = start
    cue[:end] = start + opts[:frames]

    cue[:x] = ((index % opts[:columns]) * opts[:width])
    puts "x #{cue[:x]}" if verbose

    cue[:y] = (index.to_f / opts[:columns].to_f).floor * height
    puts "y #{cue[:y]}" if verbose

    cue[:w] = opts[:width]
    cue[:h] = height

    start += opts[:frames]
    puts if verbose

    cues << cue
  end

  puts cues if verbose

  # media fragment order: x,y,w,h

end

